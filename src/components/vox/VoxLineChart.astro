---
interface DataPoint {
    label: string | number;
    value: number;
}

interface Series {
    name: string;
    data: DataPoint[];
    color?: string;
    labelEnd?: boolean;
}

interface Props {
    data?: Record<string, any>[]; // New prop for flat data
    series: Series[] | string[]; // Can now be keys
    xKey?: string; // Key for x-axis labels in flat data
    height?: number;
    showGrid?: boolean;
    showPoints?: boolean;
    yAxisMax?: number;
    trigger?: "visible" | "load";
    class?: string;
    colors?: string[]; // Allow overriding colors prop
}

const {
    data,
    series,
    xKey = "label",
    height = 400,
    showGrid = true,
    showPoints = true,
    yAxisMax,
    trigger = "visible",
    class: className,
    colors: overrideColors,
} = Astro.props;

// 1. Normalize Series Data
let normalizedSeries: Series[] = [];

if (
    data &&
    Array.isArray(series) &&
    (series.length === 0 || typeof series[0] === "string")
) {
    // Mode 1: Flat Data + Keys
    normalizedSeries = (series as string[]).map((key, index) => ({
        name: key,
        data: data.map((d) => ({
            label: d[xKey],
            value: Number(d[key]), // Ensure number
        })),
        color: overrideColors
            ? overrideColors[index % overrideColors.length]
            : undefined,
    }));
} else {
    // Mode 2: Pre-structured Series
    normalizedSeries = series as Series[];
    // Apply override colors if present
    if (overrideColors) {
        normalizedSeries = normalizedSeries.map((s, i) => ({
            ...s,
            color: s.color || overrideColors[i % overrideColors.length],
        }));
    }
}

// 2. Calculate Dimensions & Scales
const chartHeight = height;
const chartWidth = 800;
const padding = { top: 20, right: 100, bottom: 40, left: 60 };
const graphWidth = chartWidth - padding.left - padding.right;
const graphHeight = chartHeight - padding.top - padding.bottom;

// Flatten all data to find min/max
const allValues = normalizedSeries.flatMap((s) => s.data.map((d) => d.value));
const minValue = 0;
const maxValue = yAxisMax || Math.max(...allValues) * 1.1;

const dataLength = normalizedSeries[0]?.data.length || 0;
const xStep = dataLength > 1 ? graphWidth / (dataLength - 1) : graphWidth;

const getY = (val: number) => {
    return chartHeight - padding.bottom - (val / maxValue) * graphHeight;
};

const getX = (index: number) => {
    return padding.left + index * xStep;
};

// 2. Generate Paths
const generatePath = (data: DataPoint[]) => {
    return data
        .map((d, i) => {
            const x = getX(i);
            const y = getY(d.value);
            return `${i === 0 ? "M" : "L"} ${x} ${y}`;
        })
        .join(" ");
};

// 3. Colors
const defaultColors = [
    "#3B82F6", // Blue
    "#EC4899", // Pink
    "#10B981", // Emerald
    "#F59E0B", // Amber
    "#6366F1", // Indigo
    "#9CA3AF", // Gray
];

const uniqueId = Math.random().toString(36).substr(2, 9);
---

<div class={`vox-line-chart ${className || ""}`} data-trigger={trigger}>
    <svg
        viewBox={`0 0 ${chartWidth} ${chartHeight}`}
        preserveAspectRatio="xMidYMid meet"
        role="img"
        aria-label="Line Chart"
    >
        {/* Grid Lines */}
        {
            showGrid && (
                <g class="grid-lines">
                    {[0, 0.25, 0.5, 0.75, 1].map((tick) => {
                        const val = Math.round(maxValue * tick);
                        const y = getY(val);
                        return (
                            <g>
                                <line
                                    x1={padding.left}
                                    y1={y}
                                    x2={chartWidth - padding.right}
                                    y2={y}
                                    stroke="currentColor"
                                    stroke-opacity="0.1"
                                    stroke-dasharray={tick === 0 ? "" : "4 4"}
                                />
                                <text
                                    x={padding.left - 10}
                                    y={y + 4}
                                    text-anchor="end"
                                    class="axis-label"
                                >
                                    {val}
                                </text>
                            </g>
                        );
                    })}
                </g>
            )
        }

        {/* X-Axis Labels */}
        <g class="x-axis">
            {
                normalizedSeries[0]?.data.map((d, i) => {
                    // Smart label skipping: aim for max ~6 labels
                    const skip = Math.ceil(dataLength / 6);
                    if (i % skip !== 0 && i !== dataLength - 1) return null;

                    return (
                        <text
                            x={getX(i)}
                            y={chartHeight - 10}
                            text-anchor="middle"
                            class="axis-label"
                        >
                            {d.label}
                        </text>
                    );
                })
            }
        </g>

        {/* Lines */}
        {
            normalizedSeries.map((s, sIndex) => {
                const color =
                    s.color || defaultColors[sIndex % defaultColors.length];
                const pathD = generatePath(s.data);
                const lastPoint = s.data[s.data.length - 1];
                const lastX = getX(s.data.length - 1);
                const lastY = getY(lastPoint.value);

                return (
                    <g class="series-group" style={`--color: ${color}`}>
                        <path
                            d={pathD}
                            fill="none"
                            stroke={color}
                            stroke-width="3"
                            stroke-linecap="round"
                            stroke-linejoin="round"
                            class="line-path"
                        />

                        {/* Points */}
                        {showPoints &&
                            s.data.map((d, i) => (
                                <circle
                                    cx={getX(i)}
                                    cy={getY(d.value)}
                                    r="4"
                                    fill="var(--bg-color, white)"
                                    stroke={color}
                                    stroke-width="2"
                                    class="data-point"
                                    style={`--delay: ${i * 50}ms`}
                                />
                            ))}

                        {/* Direct Label */}
                        {s.labelEnd !== false && (
                            <text
                                x={lastX + 10}
                                y={lastY + 4}
                                fill={color}
                                font-weight="bold"
                                class="series-label"
                            >
                                {s.name}
                            </text>
                        )}
                    </g>
                );
            })
        }
    </svg>
</div>

<script>
    const setup = () => {
        const observer = new IntersectionObserver(
            (entries) => {
                entries.forEach((entry) => {
                    if (entry.isIntersecting) {
                        entry.target.classList.add("in-view");
                        observer.unobserve(entry.target);
                    }
                });
            },
            { threshold: 0.3 }, // Wait until 30% visible
        );

        document
            .querySelectorAll('.vox-line-chart[data-trigger="visible"]')
            .forEach((el) => observer.observe(el));

        document
            .querySelectorAll('.vox-line-chart[data-trigger="load"]')
            .forEach((el) => el.classList.add("in-view"));
    };

    document.addEventListener("astro:page-load", setup);
    setup();
</script>

<style>
    .vox-line-chart {
        width: 100%;
        height: auto;
        overflow: visible;
        --bg-color: #fff; /* Should match container bg */
    }

    :global(.theme-dark) .vox-line-chart {
        --bg-color: #222;
    }

    .axis-label {
        font-size: 12px;
        fill: #777;
        font-family: inherit;
    }

    .series-label {
        font-size: 14px;
        font-family: inherit;
    }

    /* Animation: Draw Line */
    .line-path {
        stroke-dasharray: 2000;
        stroke-dashoffset: 2000;
        transition: stroke-dashoffset 2s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .vox-line-chart.in-view .line-path {
        stroke-dashoffset: 0;
    }

    /* Animation: Points Fade In */
    .data-point {
        opacity: 0;
        transition: opacity 0.3s ease;
        transition-delay: calc(
            1s + var(--delay)
        ); /* Start appearing after line half drawn */
    }

    .vox-line-chart.in-view .data-point {
        opacity: 1;
    }

    /* Animation: Label Slide In */
    .series-label {
        opacity: 0;
        transform: translateX(-10px);
        transition: all 0.5s ease;
        transition-delay: 2s; /* After line finishes */
    }

    .vox-line-chart.in-view .series-label {
        opacity: 1;
        transform: translateX(0);
    }
</style>
